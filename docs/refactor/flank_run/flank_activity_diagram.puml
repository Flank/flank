@startuml
'https://plantuml.com/activity-diagram-beta

start
skinparam ConditionEndStyle hline
:main;
partition "cli command" #LightGreen {
  #red :TODO iOS sharding is performed when validation is performed;
  split
  :login;

  split again
  partition "new test run" #LightBlue  {
    partition "run tests" #LightBlue {

      split
      partition "run android" #LightBlue {
        partition "before run tests" #LightBlue {
          #snow :start stop watch;
          #snow :prepare result directory;
          #snow :ensure not running on mock;
        }
        #snow :prepare data;
        #snow :upload files;
        partition "create test contexts" #LightBlue {
          #snow :resolve apks;
          partition "setup shards" #LightBlue {
            #snow :prepare test filters;
            repeat
              split
              partition "instrumentation with user sharding" #LightBlue {
                #snow :download apks;
                partition "calculate shards" #LightBlue {
                  #snow :get flank test method;
                  #snow :create shards by test for shards;
                  #snow :add always run methods;
                  #snow :shards>
                }
              }
              split again
              partition "instrumentation with flank sharding" #LightBlue {
                #snow :download apks;
                partition "calculate shards" #LightBlue {
                  #snow :get flank test methods;
                  partition "get old results or default" #LightBlue {
                    #snow :download xml results;
                    partition "parse all suites xml" #LightBlue {
                      #snow :fix html codes;
                      #snow :read value;
                    }
                  }
                  partition "calculate shards count" #LightBlue {
                    #snow :create tests duration map;
                    #snow :get test method time;
                    #snow :shards count>
                  }
                  partition "create shards by shard count" #LightBlue {
                    #snow :create tests duration map;
                    partition "create test methods" #LightBlue {
                      #snow :get fallback times;
                      repeat
                        #snow :get test method time;
                        #snow :enrich test method with time;
                      repeat while (for each test)
                      #snow :list of test methods with time>
                    }
                    #snow :add always run methods;
                    #snow :print cache info;
                    #snow :print shards info;
                    #snow :shards>
                  }
                }
              }
              split again
              #snow :robo / game loop test\n      __no sharding__;
              end split
            repeat while (for each context)
          }
          #snow :drop empty shards;
          #snow :shards + ignored tests list>
        }
        partition "dump shards" #LightBlue {
          #snow :as matrix test shards;
          partition "save shards" #LightBlue {
            if (printer ?) then
              #snow :pretty;
            else
              #snow :obfuscated;
            endif
            #snow :save to file;
          }
          #snow :upload dump file;
        }
        #snow :upload test files;
        repeat
          #snow :create test config;
          #snow :build test matrix;
          #snow :execute with retry;
        repeat while (for each context)
        #snow :before run message;
        partition "after test run" #LightBlue {
          #snow :update matrix file;
          #snow :save config file;
          #snow :save session id;
          #snow :upload session id;
          repeat
            #snow :get and print\nmatrix weblink;
          repeat while (for each test matrix)
        }
        #snow :test results>
      }

      split again
      partition "run ios" #LightBlue {
        partition "before run tests" #LightBlue {
          #snow :start stop watch;
          #snow :prepare result directory;
          #snow :ensure not running on mock;
        }
        #snow :prepare data;
        #snow :upload files;
        partition "dump shards" #LightBlue {
          #snow :prepare xc test run shards;
          partition "save shards" #LightBlue {
            if (printer ?) then
              #snow :pretty;
            else
              #snow :obfuscated;
            endif
            #snow :save to file;
          }
          #snow :upload dump file;
        }
        #snow :before run message;
        repeat
          split
          partition "xc test run" #LightBlue {
            #snow :create counter;
            #snow :upload files;
            #snow :xc test run data as byte array;
            #snow :upload xc test file;
            #snow :xc test context>
          }
          split again
          partition "game loop test run" #LightBlue {
            #snow :create counter;
            #snow :upload files;
            #snow :game loop test context>
          }
          end split
          #snow :build test matrix;
          #snow :execute with retry;
        repeat while (for each context)
        partition "after test run" #LightBlue {
          #snow :update matrix file;
          #snow :save config file;
          #snow :save session id;
          #snow :upload session id;
          repeat
            #snow :get and print\nmatrix weblink;
          repeat while (for each test matrix)
        }
        #snow :test results>
      }
      end split
    }

    partition "poll matrices" #LightBlue {
      while (all matrices completed?) is (no)
        #snow :refresh;
        #snow :print status;
      endwhile (yes)
      #snow :update matrix map;
    }
    partition "generate report" #LightBlue {
      partition "parse test suite" #LightBlue {
        if (iOS test run\nor\nuse legacy junit result ?) then (yes)
          #snow :process xml from file;
        else (no)
          partition "refresh test matrices and get executions" #LightBlue {
            repeat
              #snow :refresh;
            repeat while (for each matrix)
            #snow :get test executions;
          }
          partition "create junit result" #LightBlue {
            partition "create test execution data" #LightBlue {
              fork
                #snow :list test cases;
              fork again
                #snow :get step results;
              end fork
              #snow :test execution data>
            }
            #snow :prepare for junit results;
            partition "create junit test suites" #LightBlue {
              repeat
                #snow :create test suite overview data;
              repeat while(for each execution data)
            }
          }
        endif
        #snow :JUnit test result>
      }
      if (use legacy junit results ?) then (yes)
        #snow :remove duplicated test cases;
      endif
      partition "generate cost report" #LightBlue {
        #snow :upload report;
      }
      partition "generate matrix results report" #LightBlue {
        #snow :upload report;
      }
      if (any test failed?) then (yes)
        partition "generate HTML report" #LightBlue {
          #snow :upload report;
        }
      else (no)
      endif
      partition "generate junit report" #LightBlue {
        #snow :get ignored test cases;
        #snow :xml to string;
        #snow :upload report;
      }
      partition "refresh test matrices and get executions" #LightBlue {
        repeat
          #snow :refresh;
        repeat while (for each matrix)
        #snow :get test executions;
      }
      :process junit results;
      partition "create and upload performance metrics for android" #LightBlue {
        partition "get and upload performance metrics" #LightBlue {
          repeat
            #snow :download performance metric;
            #snow :save metric to file;
            #snow :upload metric file;
          repeat while (for each test execution)
        }
      }
    }
    :fetch artifacts;
    :print matrices web links;
    :validate matrices;
  }

  split again
  partition "refresh last run" #LightBlue {
    :get last matrices;
    :get last args;
    :refresh matrices;
    :poll matrices;
    :fetch artifacts;
    :generate report;
    :validate matrices;
  }

  split again
  partition "cancel last run" #LightBlue {
    :get last matrices;
    :get last args;
    :cancel matrices;
  }

  split again
  partition "android / ios" #LightBlue {
  split

  partition "configuration" #LightBlue {
    split
    :print locales description;
    split again
    :print locales table;
    split end
  }

  split again
  partition "models" #LightBlue {
    split
    :print description;
    split again
    :print table;
    split end
  }

  split again
  partition "supported orientations" #LightBlue {
    split
    :print table;
    split end
  }

  split again
  partition "versions" #LightBlue {
    split
    :print description;
    split again
    :print table;
    split end
  }

  split again
  :print ip blocks list;

  split again
  :print network configurations;

  split again
  :print network profile description;

  split again
  :print provided software;

  end split
}
end split
stop

@enduml
